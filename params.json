{
  "name": "Parse-js",
  "tagline": "Utility library for object structure conversion.",
  "body": "# parse-js\r\n[![CircleCI](https://circleci.com/gh/bubobox/parse-js.svg?style=svg)](https://circleci.com/gh/bubobox/parse-js)\r\n\r\nUtility library for object structure conversion.\r\n\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n  - [.parse()](#parse)\r\n  - [.reverse()](#reverse)\r\n  - [.transform()](#transform)\r\n  - [.chain()](#chain)\r\n- [Configuration](#configuration)\r\n  - [.setOption() / .getOption()](#configuration)\r\n- [Transformers](#transformers)\r\n  - [.select()](#select)\r\n  - [.match()](#match)\r\n  - [.rename()](#rename)\r\n  - [.map()](#map)\r\n  - [.group()](#group)\r\n  - [.oneOf()](#oneof)\r\n  - [.equals()](#equals)\r\n  - [.constant()](#constant)\r\n  - [.date()](#date)\r\n  - [.bool()](#bool)\r\n  - [.number()](#number)\r\n  - [.string()](#string)\r\n  - [.array()](#array)\r\n  - [.base64()](#base64)\r\n  - [.json()](#json)\r\n  - [.spec()](#spec)\r\n  - [.multilingual()](#multilingual)\r\n  - [.stripPrefix()](#stripprefix)\r\n\r\n## Installation\r\n\r\n```shell\r\nnpm install --save parse-js\r\n```\r\n\r\n## Usage\r\n\r\nA parser always starts with a call to `parse()`, next you can chain any transformer of of that as is required.\r\n\r\n```javascript\r\nconst parse = require('parse-js');\r\n\r\nparse().bool().parse('true'); // true\r\nparse().match('a').parse({\r\n    atest: 'test123',\r\n    btest: 'test456'\r\n}); // { atest: 'test123' }\r\n```\r\n\r\nParse also accepts one argument which can be the key to extract from the object to parse. Passing this argument will automatically chain the `select` transformer.\r\n\r\n```javascript\r\nconst parse = require('parse-js');\r\n\r\nparse('a-key').parse({\r\n    'a-key': 'a-value',\r\n    'some-key': 'some-value'\r\n}); // 'a-value'\r\n```\r\n\r\nThis is equivalent to:\r\n\r\n```javascript\r\nconst parse = require('parse-js');\r\n\r\nparse().select('a-key').parse({\r\n    'a-key': 'a-value',\r\n    'some-key': 'some-value'\r\n}); // 'a-value'\r\n```\r\n\r\n#### .parse()\r\n\r\n```javascript\r\n.parse(data)\r\n```\r\n\r\nWhenever `.parse()` is called the configured chain will be executed on the first argument `data`.\r\n\r\nIf the option `direction` is set to `REVERSE` this method will simply return\r\nthe `data` argument as is without modifying it.\r\n\r\nExample:\r\n```javascript\r\nparse('test-key').base64().parse({ 'test-key': 'SGVsbG8gV29ybGQ=' });\r\n// Hello World\r\n```\r\n\r\n#### .reverse()\r\n\r\n```javascript\r\n.reverse(sourceData)\r\n```\r\n\r\nThe `.reverse()` method will apply all the `reverse` methods of each transformer\r\nand attempts to reassembly the original object based on the sourceData.\r\n\r\nExample:\r\n\r\n```javascript\r\nparse('test-key').base64().reverse('Hello World');\r\n// {\r\n//    'test-key': 'SGVsbG8gV29ybGQ='\r\n// }\r\n```\r\n\r\n#### .transform()\r\n\r\n```javascript\r\n.transform(parser, [reverser])\r\n```\r\n\r\nThis method allows you to chain your own custom `parser` and `reverser`. Both\r\nthe `parser` and `reverser` take one argument as input which is the value to\r\nbe parsed or reversed.\r\n\r\nInstead of supplying both methods as separator arguments you can also pass\r\nthe `parser` and `reverser` as an object with both the keys defined.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Increment / decrement transformer\r\nfunction parser(v) { return v + 1; };\r\nfunction reverser(v) { return v - 1; };\r\n\r\nparse().transform(parser, reverser).parse(1); // 2\r\nparse().transform(parser, reverser).reverse(3); // 2\r\n\r\n// or alternatively\r\nconst transformer = {\r\n    parser: parser,\r\n    reverser: reverser\r\n}\r\n\r\nparse().transform(transformer).parse(1); // 2\r\n```\r\n\r\n#### .chain()\r\n\r\n```javascript\r\n.chain(configurator)\r\n```\r\n\r\nThe `.chain()` method allows your to create pre-defined chains which can be\r\neasily re-used for different parsers.\r\n\r\nExample:\r\n\r\nThis example created a pre-defined one-way base64 parser.\r\n\r\n```javascript\r\nfunction base64_decode(p) {\r\n    return p.base64().setOption('direction', 'PARSE');\r\n}\r\n\r\nparse().select('some-key')\r\n    .chain(base64_decode)\r\n    .parse({ 'some-key': 'SGVsbG8gV29ybGQ=' }); // Hello World\r\n```\r\n\r\n### Configuration\r\n\r\nBoth `parse-js` instances and the `parse` method have methods to set global\r\noptions `setOption` and `getOption`, these can be used to configure\r\ntransformers that have global settings.\r\n\r\n```javascript\r\nParse.setOption(key, value);\r\nParse.getOption(key);\r\n\r\nparse().setOption(key, value);\r\nparse().getOption(key);\r\n```\r\n\r\nCurrently only the [multilingual transformer](#multilingual) has such options.\r\n\r\nThe behaviour of a `parse-js` chain can be altered using the `direction` option\r\nwhich configures in which directions the transformers should be applied. When\r\nset to `PARSE` the `.reverse()` calls will not touch the data supplied. Similarly\r\nsetting `direction` to `REVERSE` will leave the data untouched as `.parse()` is\r\ncalled. By default both directions are enabled and the option is set to `ANY`.\r\n\r\n### Transformers\r\n\r\n#### .select()\r\n\r\n```javascript\r\nparse().select(key)\r\n```\r\n\r\nSelects a value from the object provided to the final `.parse()` call, the key supplied here can be any key supported by [lodash get](https://lodash.com/docs/4.16.0#get).\r\n\r\n\r\n#### .match()\r\n\r\n```javascript\r\nparse().match(valueToMatch)\r\n```\r\n\r\nOnly selects those properties from an object that match `valueToMatch`.\r\n\r\n- `valueToMatch` can either be a string or a regular expression.\r\n\r\n#### .rename()\r\n\r\n```javascript\r\nparse().rename(nameParser, nameReverser);\r\n```\r\n\r\nConverts key names using a function for each transition.\r\n\r\n- `nameParser(key, value)` will be called with the original key and value as arguments and should return the new key.\r\n- `nameReverser(key, value)` will be called with the generated key and the value set on the object and should return the key to which this value should be written.\r\n\r\n#### .map()\r\n\r\n```javascript\r\nparse().map(callback)\r\n```\r\n\r\nMap will walk each key of a select value and call the `callback` function with a new instance of `parse-js` specific to that key.\r\n\r\n- `callback(parse)` will be called with a new instance of parse for each key, which you can then customize by adding new chained transformers.\r\n\r\nExample\r\n\r\n```javascript\r\nparse().map(p => p.number()).parse({\r\n    a: '123',\r\n    b: 0,\r\n    c: '12.222,3'\r\n}); // { a: 123, b: 0, c: 12222.3 }\r\n```\r\n\r\n\r\n#### .group()\r\n\r\n```\r\nparse().group(regex, key, index)\r\n```\r\n\r\n`group` will walk over each key of an object matching it against regular expression `regex`. If it matches the value will be stored at `result[match[key]][match[index]]`, where `match` is the set of matching groups from `regex`. If a key does not match the `regex` it will be re-attached to the object untouched.\r\n\r\n- The `key` argument should be set to the index of the matching group that selects the new key to use.\r\n- The `index` arguments should be set to the index of the matching group that selects the sub-key under which to store the value.\r\n\r\nExample:\r\n\r\n```javascript\r\nparse().group(/(a|b|c)-(name|value)/, 1, 2).parse({\r\n    'a-name': 'a-name',\r\n    'b-name': 'b-name',\r\n    'c-value': 'c-value',\r\n    'b-value': 'b-value',\r\n    'c-name': 'c-name',\r\n    'a-value': 'a-value'\r\n});\r\n// {\r\n//    a: { value: 'a-value', name: 'a-name' },\r\n//    b: { value: 'b-value', name: 'b-name' },\r\n//    c: { value: 'c-value', name: 'c-name' }\r\n// }\r\n```\r\n\r\n#### .oneOf()\r\n\r\n```javascript\r\nparse().oneOf(parsers, [options = {}])\r\n```\r\n\r\n`oneOf` lets you define multiple parsers of which the first in the list with a\r\nresult that is valid according to the `test` option will be used.\r\n\r\n- `parsers` an array of `parse-js` parsers to go through.\r\n- `options`\r\n  - `test` a method which returns true if the result of a parser is valid. (default: `!isEmpty(v)`)\r\n  - `reverseAll` controls whether all parsers are called to reverse the value or only the first one. (default: `true`)\r\n\r\nExample:\r\n\r\n```javascript\r\nparse().oneOf([\r\n    parse().select('givenName').string(),\r\n    parse().select('firstName').string(),\r\n    parse().select('email')\r\n]).parse({ 'firstName': 'John', email: 'john.doe@gmail.com' });\r\n// 'John'\r\n```\r\n\r\n#### .equals()\r\n\r\n```javascript\r\nparse().equals(valueToMatch, [options = {}])\r\n```\r\n\r\nIf the selected value matched `valueToMatch` it will return `true`, if it does not it will return `false`.\r\n\r\n- `valueToMatch` can be either a regular expressions, function or simply any value.\r\n- `options` can be used to change behaviour of the transformer\r\n  - `strict` will ensure `===` comparison is used when comparing. (default: `false`).\r\n  - `reverse` can be set to the value that should be set when reversing a `true` value. (default: `valueToMatch`)\r\n\r\nExample:\r\n\r\n```javascript\r\nparse().equals('some-value').parse('some-other-value'); // false\r\nparse().equals('some-value').parse('some-value'); // true\r\n```\r\n\r\n#### .constant()\r\n\r\n```javascript\r\nparse().constant(constantValue, [options = {}])\r\n```\r\n\r\nAlways returns `constantValue` from `parse` and `reverse`.\r\nThe value returned from `reverse` can be different from `constantValue`\r\nusing the `reverseValue` option.\r\n\r\n- `constantValue` the value that will be returned by this transformer.\r\n- `options`\r\n  - `reverseValue` If `reverse` should return a different value it can be configured using this option.\r\n\r\nExample:\r\n\r\n```javascript\r\nparse().constant('a-constant').parse('some-value'); // 'a-constant'\r\nparse().constant('a-constant', {\r\n    reverseValue: 'b-constant'\r\n}).reverse('some-value'); // 'b-constant'\r\n```\r\n\r\n#### .date()\r\n\r\n```javascript\r\nparse().date([nowOnInvalid = false])\r\n```\r\n\r\nConverts the selected value into a javascript date object.\r\n\r\n- `nowOnInvalid` If set to true will return the current date-time whenever the value being parsed is not a valid date.\r\n\r\n#### .bool()\r\n\r\n```javascript\r\nparse().bool([options = {}])\r\n```\r\n\r\nConverts the selected value to a boolean value.\r\n\r\n- `options`\r\n  - `defaultValue` when the value being parsed is `undefined` what should be set as the default value.\r\n  - `reverseTo` configures the datatype to which the boolean values are reversed. Valid options are `BOOLEAN`, `STRING` or `NUMBER`.\r\n\r\n#### .number()\r\n\r\n```javascript\r\nparse().number([options = {}])\r\n```\r\n\r\nConverts the selected value to a number.\r\n\r\n- `options`\r\n  - `NaNValue` the value that will be set when the selected value can not be converted. (default: `0`)\r\n  - `normalizer` a function used to normalize strings to number-like strings. The default handles removing multiple comma or dots in the string.\r\n  - `base` the base in which the value is expressed. (default: `10`)\r\n\r\n\r\n#### .string()\r\n\r\n```javascript\r\nparse().string([options = {}])\r\n```\r\n\r\nConverts the selected value to a string.\r\nThe selected value will be concatenated with an empty string which will call the `toString()` method of most values.\r\n\r\n- `options`\r\n  - `defaultValue` the value to return whenever the selected value is `undefined`.\r\n\r\n#### .array()\r\n\r\n```javascript\r\nparse().array([options = {}])\r\n```\r\n\r\nThis transformer will ensure that the selected value will be converted to an array. Whenever this fails it will return an empty array.\r\n\r\n- `options`\r\n  - `mode` the methods that are allowed to be used to convert values to arrays. (default: `ANY`). Valid options are `ANY`, `JSON` and `SEPARATOR`.\r\n  - `separator` the separator to be used when `mode` is set to `ANY` or `SEPARATOR`. (default: `,`)\r\n\r\n#### .base64()\r\n\r\n```javascript\r\nparse().base64([options = {}])\r\n```\r\n\r\nHandles conversion from and to base64 strings.\r\n\r\n- `options`\r\n  - `allowBinary` when this option is set to `true` the `isPrintable` check will be disabled. Because of this any valid base64 formatted string will be decoded.\r\n\r\n#### .json()\r\n\r\n```javascript\r\nparse().json([options = {}])\r\n```\r\n\r\nConverts the selected value from and to a JSON string.\r\n\r\n- `options`\r\n  - `defaultValue` will be returned whenever no valid JSON string is selected.\r\n\r\n#### .spec()\r\n\r\n```javascript\r\nparse().spec(specification)\r\n```\r\n\r\nA specification is an object that has the desired properties of the target format, where the values are the parsers that generate the value to store with this property. This allows a source format to be converted to the desired format using `parse-js`.\r\n\r\n- `specification` an object containing `key` - `parser` combinations.\r\n\r\nExample:\r\n```javascript\r\nparse().spec({\r\n    one: parse('two'),\r\n    two: parse('one').number(),\r\n    three: parse('four').array(),\r\n    nested: {\r\n        one: parse('one'),\r\n        two: parse('four').json()\r\n    }\r\n}).parse({ one: '15.333.23', two: 'two', four: '[1,2,3,4,5]' });\r\n// {\r\n//     one: 'two',\r\n//     two: 15333.23,\r\n//     three: [1, 2, 3, 4, 5],\r\n//     nested: {\r\n//         one: '15.333.23',\r\n//         two: [1, 2, 3, 4, 5]\r\n//     }\r\n// }\r\n```\r\n\r\n#### .multilingual()\r\n\r\n```javascript\r\nparse().multilingual(languages)\r\n```\r\n\r\nWill group keys with language suffixes as defined by `group()`\r\n\r\n- `languages` configures the languages that are supported. This option can also be set using the `setOption()` method of the parse-js instance or `Parse.setOption()`. When using `setOption()` this option is configured using the key `multilingual.languages`.\r\n\r\nExample:\r\n\r\n```javascript\r\nparse().multilingual(['en', 'nl', 'fr', 'de']).parse({\r\n    keyEn: 'english text',\r\n    keyNl: 'dutch text'\r\n});\r\n// {\r\n//     key: { en: 'english text', nl: 'dutch text' }\r\n// }\r\n```\r\n\r\n#### .stripPrefix()\r\n\r\n```javascript\r\nparse().stripPrefix(prefix)\r\n```\r\n\r\nSelects keys that start with `prefix` and removes that `prefix` from the target object.\r\n\r\n- `prefix` the prefix that keys should contain and that will be removed.\r\n\r\nExample:\r\n\r\n```javascript\r\nparse().stripPrefix('test').parse({\r\n    atest: 'value-1',\r\n    test1: 'value-2',\r\n    test2: 'value-3'\r\n});\r\n// { 1: 'value-2', 2: 'value-3' }\r\n```\r\n\r\n## Contribute\r\n\r\nWe really appreciate any contribution you would like to make, so don't\r\nhesitate to report issues or submit pull requests.\r\n\r\n## License\r\n\r\nThis project is released under a MIT license.\r\n\r\n## About us\r\n\r\nIf you would like to know more about us, be sure to have a look at [our website](https://www.bubobox.com), or our Twitter accounts [BuboBox](https://twitter.com/BuboBox), [Sitebase](https://twitter.com/Sitebase), [JorgenEvens](https://twitter.com/JorgenEvens)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}